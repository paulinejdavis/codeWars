// Sorting is the process of arranging data in a particular order. In JavaScript, there are many sorting algorithms that can be used to
//  sort arrays or other collections of data. Here are some JS and algorithms sorting fundamentals:

//  Comparison-Based Sorting: Most common sorting algorithms are based on
//  comparing elements in the data set and swapping them if necessary to place 
//  them in order. Examples include bubble sort, selection sort, insertion sort, quicksort, mergesort, and heapsort.
//  In-Place Sorting: In-place sorting algorithms sort the data without 
// requiring additional memory allocation. Examples include bubble sort, 
// insertion sort, selection sort, heapsort, and quicksort.
//  Stable Sorting: Stable sorting algorithms preserve the relative order 
// of equal elements in the data set. Examples include insertion sort,
//  mergesort, and Timsort.
//  Unstable Sorting: Unstable sorting algorithms do not preserve the 
// relative order of equal elements in the data set. Examples 
// include selection sort and quicksort.
//  Time Complexity: Sorting algorithms have different time complexities, 
// which determine how long they take to sort data sets of different sizes. 
// Some algorithms, such as bubble sort and selection sort, have a 
// time complexity of O(n^2) and are not suitable for large data sets. 
// Other algorithms, such as quicksort and mergesort, have a time complexity
//  of O(n log n) and are more efficient for large data sets.
//  Space Complexity: Sorting algorithms also have different space 
// complexities, which determine how much additional memory is required 
// to sort the data. In-place sorting algorithms have a space complexity
//  of O(1), while other algorithms may require additional memory to store 
//  temporary data structures.
//  Built-In Sorting Functions: JavaScript provides built-in functions 
// for sorting arrays, such as sort(). These functions usually implement 
// efficient sorting algorithms and are optimized for performance, but
// may not be suitable for all use cases.
//  Understanding these fundamentals can help you choose the right 
// sorting algorithm for your use case and optimize the performance of 
// your code.